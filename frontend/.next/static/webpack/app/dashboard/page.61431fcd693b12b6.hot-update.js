"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./lib/progressStates.ts":
/*!*******************************!*\
  !*** ./lib/progressStates.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PROGRESS_STATE_CONFIG: function() { return /* binding */ PROGRESS_STATE_CONFIG; },\n/* harmony export */   determineProgressState: function() { return /* binding */ determineProgressState; },\n/* harmony export */   getAnimationClass: function() { return /* binding */ getAnimationClass; }\n/* harmony export */ });\n/**\n * Unified progress state model for scraping and ingestion workflow\n * \n * This provides a clear state machine that maps backend events to user-visible states\n */ const PROGRESS_STATE_CONFIG = {\n    ready: {\n        label: \"Ready\",\n        icon: \"\\uD83D\\uDFE2\",\n        color: \"var(--color-text-muted)\",\n        bgColor: \"var(--color-surface-elevated)\",\n        borderColor: \"var(--color-border)\",\n        animation: \"none\",\n        description: \"Idle, waiting for user input\"\n    },\n    scrape_initiated: {\n        label: \"Scrape Initiated\",\n        icon: \"\\uD83D\\uDFE1\",\n        color: \"var(--color-primary)\",\n        bgColor: \"rgba(0, 159, 61, 0.2)\",\n        borderColor: \"rgba(0, 159, 61, 0.3)\",\n        animation: \"pulse\",\n        description: \"User triggered manual scrape\"\n    },\n    scraping: {\n        label: \"Scraping\",\n        icon: \"\\uD83D\\uDFE0\",\n        color: \"var(--color-primary)\",\n        bgColor: \"rgba(0, 159, 61, 0.2)\",\n        borderColor: \"rgba(0, 159, 61, 0.3)\",\n        animation: \"spin\",\n        description: \"Apify run in progress\"\n    },\n    processing: {\n        label: \"Processing\",\n        icon: \"\\uD83D\\uDFE3\",\n        color: \"#a78bfa\",\n        bgColor: \"rgba(167, 139, 250, 0.2)\",\n        borderColor: \"rgba(167, 139, 250, 0.3)\",\n        animation: \"spin\",\n        description: \"Data retrieved, parsing or transforming\"\n    },\n    ingesting: {\n        label: \"Ingesting\",\n        icon: \"\\uD83D\\uDFE9\",\n        color: \"var(--color-success)\",\n        bgColor: \"rgba(34, 197, 94, 0.2)\",\n        borderColor: \"rgba(34, 197, 94, 0.3)\",\n        animation: \"spin\",\n        description: \"Database insert or update running\"\n    },\n    updating_ui: {\n        label: \"Updating UI\",\n        icon: \"\\uD83D\\uDFE6\",\n        color: \"var(--color-info)\",\n        bgColor: \"rgba(59, 130, 246, 0.2)\",\n        borderColor: \"rgba(59, 130, 246, 0.3)\",\n        animation: \"fade\",\n        description: \"New data being pushed to the frontend store\"\n    },\n    completed: {\n        label: \"Completed\",\n        icon: \"âœ…\",\n        color: \"var(--color-success)\",\n        bgColor: \"rgba(34, 197, 94, 0.2)\",\n        borderColor: \"rgba(34, 197, 94, 0.3)\",\n        animation: \"fade\",\n        description: \"Ingestion finished, UI refreshed\"\n    },\n    error: {\n        label: \"Error\",\n        icon: \"\\uD83D\\uDD34\",\n        color: \"var(--color-error)\",\n        bgColor: \"rgba(239, 68, 68, 0.2)\",\n        borderColor: \"rgba(239, 68, 68, 0.3)\",\n        animation: \"none\",\n        description: \"Scrape or ingestion failed\"\n    }\n};\n/**\n * Determine progress state from backend data\n */ function determineProgressState(scrapeStatus, lastScrapedAt, isScraping, jobStatuses) {\n    // Error state takes priority\n    if (scrapeStatus === \"failed\") {\n        return \"error\";\n    }\n    // HIGHEST PRIORITY: If scrape_status is completed, always show completed\n    if (scrapeStatus === \"completed\") {\n        return \"completed\";\n    }\n    // Check job statuses for more granular state\n    if (jobStatuses) {\n        var _jobStatuses_ingestion, _jobStatuses_reviewsscraper, _jobStatuses_roomsscraper;\n        const ingestionStatus = (_jobStatuses_ingestion = jobStatuses[\"ingestion\"]) === null || _jobStatuses_ingestion === void 0 ? void 0 : _jobStatuses_ingestion.status;\n        const reviewsStatus = (_jobStatuses_reviewsscraper = jobStatuses[\"reviews-scraper\"]) === null || _jobStatuses_reviewsscraper === void 0 ? void 0 : _jobStatuses_reviewsscraper.status;\n        const roomsStatus = (_jobStatuses_roomsscraper = jobStatuses[\"rooms-scraper\"]) === null || _jobStatuses_roomsscraper === void 0 ? void 0 : _jobStatuses_roomsscraper.status;\n        // If ingestion is completed, we're done\n        if (ingestionStatus === \"completed\") {\n            return \"completed\";\n        }\n        // If ingestion is running, show ingesting\n        if (ingestionStatus === \"running\") {\n            return \"ingesting\";\n        }\n        // If reviews scraper is running, show processing\n        if (reviewsStatus === \"running\") {\n            return \"processing\";\n        }\n        // If rooms scraper is running, show scraping\n        if (roomsStatus === \"running\") {\n            return \"scraping\";\n        }\n        // If all jobs are completed (or no jobs exist), check scrape_status\n        const allJobsCompleted = (!roomsStatus || roomsStatus === \"completed\" || roomsStatus === \"failed\") && (!reviewsStatus || reviewsStatus === \"completed\" || reviewsStatus === \"failed\") && (!ingestionStatus || ingestionStatus === \"completed\" || ingestionStatus === \"failed\");\n        if (allJobsCompleted && lastScrapedAt) {\n            return \"completed\";\n        }\n    }\n    // If actively scraping (frontend state), show scraping\n    if (isScraping) {\n        return \"scraping\";\n    }\n    // If status is running and we have last_scraped_at, check if jobs are done\n    if (scrapeStatus === \"running\" && lastScrapedAt && !isScraping) {\n        if (jobStatuses) {\n            const allJobsDone = (!jobStatuses[\"rooms-scraper\"] || jobStatuses[\"rooms-scraper\"].status === \"completed\" || jobStatuses[\"rooms-scraper\"].status === \"failed\") && (!jobStatuses[\"reviews-scraper\"] || jobStatuses[\"reviews-scraper\"].status === \"completed\" || jobStatuses[\"reviews-scraper\"].status === \"failed\") && (!jobStatuses[\"ingestion\"] || jobStatuses[\"ingestion\"].status === \"completed\" || jobStatuses[\"ingestion\"].status === \"failed\");\n            if (allJobsDone) {\n                return \"completed\";\n            }\n        }\n        // If scrape was more than 20 minutes ago and we're not actively scraping, assume completed\n        const lastScraped = new Date(lastScrapedAt);\n        const now = new Date();\n        const minutesSinceScrape = (now.getTime() - lastScraped.getTime()) / (1000 * 60);\n        if (minutesSinceScrape > 20) {\n            return \"completed\";\n        }\n        return \"scraping\";\n    }\n    // If status is running and we're actively scraping, show scraping\n    if (scrapeStatus === \"running\") {\n        return \"scraping\";\n    }\n    if (scrapeStatus === \"pending\" || !lastScrapedAt) {\n        return \"ready\";\n    }\n    // Default: if we have last_scraped_at but no clear status, assume completed\n    return \"completed\";\n}\n/**\n * Get animation class for a progress state\n */ function getAnimationClass(state) {\n    const config = PROGRESS_STATE_CONFIG[state];\n    if (!config.animation || config.animation === \"none\") {\n        return \"\";\n    }\n    switch(config.animation){\n        case \"pulse\":\n            return \"animate-pulse\";\n        case \"spin\":\n            return \"animate-spin\";\n        case \"fade\":\n            return \"opacity-75\";\n        default:\n            return \"\";\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9wcm9ncmVzc1N0YXRlcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7OztDQUlDLEdBc0JNLE1BQU1BLHdCQUFvRTtJQUMvRUMsT0FBTztRQUNMQyxPQUFPO1FBQ1BDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxhQUFhO0lBQ2Y7SUFDQUMsa0JBQWtCO1FBQ2hCUCxPQUFPO1FBQ1BDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxhQUFhO0lBQ2Y7SUFDQUUsVUFBVTtRQUNSUixPQUFPO1FBQ1BDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxhQUFhO0lBQ2Y7SUFDQUcsWUFBWTtRQUNWVCxPQUFPO1FBQ1BDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxhQUFhO0lBQ2Y7SUFDQUksV0FBVztRQUNUVixPQUFPO1FBQ1BDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxhQUFhO0lBQ2Y7SUFDQUssYUFBYTtRQUNYWCxPQUFPO1FBQ1BDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxhQUFhO0lBQ2Y7SUFDQU0sV0FBVztRQUNUWixPQUFPO1FBQ1BDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxhQUFhO0lBQ2Y7SUFDQU8sT0FBTztRQUNMYixPQUFPO1FBQ1BDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxhQUFhO0lBQ2Y7QUFDRixFQUFFO0FBRUY7O0NBRUMsR0FDTSxTQUFTUSx1QkFD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T0FBUTJCLE9BQU8zQixTQUFTO1FBQ3RCLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNUO1lBQ0UsT0FBTztJQUNYO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3Byb2dyZXNzU3RhdGVzLnRzPzcyODYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVbmlmaWVkIHByb2dyZXNzIHN0YXRlIG1vZGVsIGZvciBzY3JhcGluZyBhbmQgaW5nZXN0aW9uIHdvcmtmbG93XG4gKiBcbiAqIFRoaXMgcHJvdmlkZXMgYSBjbGVhciBzdGF0ZSBtYWNoaW5lIHRoYXQgbWFwcyBiYWNrZW5kIGV2ZW50cyB0byB1c2VyLXZpc2libGUgc3RhdGVzXG4gKi9cblxuZXhwb3J0IHR5cGUgUHJvZ3Jlc3NTdGF0ZSA9XG4gIHwgJ3JlYWR5JyAgICAgICAgICAgICAgLy8g8J+foiBJZGxlLCB3YWl0aW5nIGZvciB1c2VyIGlucHV0XG4gIHwgJ3NjcmFwZV9pbml0aWF0ZWQnICAgLy8g8J+foSBVc2VyIHRyaWdnZXJlZCBtYW51YWwgc2NyYXBlXG4gIHwgJ3NjcmFwaW5nJyAgICAgICAgICAgIC8vIPCfn6AgQXBpZnkgcnVuIGluIHByb2dyZXNzXG4gIHwgJ3Byb2Nlc3NpbmcnICAgICAgICAgIC8vIPCfn6MgRGF0YSByZXRyaWV2ZWQsIHBhcnNpbmcgb3IgdHJhbnNmb3JtaW5nXG4gIHwgJ2luZ2VzdGluZycgICAgICAgICAgIC8vIPCfn6kgRGF0YWJhc2UgaW5zZXJ0IG9yIHVwZGF0ZSBydW5uaW5nXG4gIHwgJ3VwZGF0aW5nX3VpJyAgICAgICAgIC8vIPCfn6YgTmV3IGRhdGEgYmVpbmcgcHVzaGVkIHRvIHRoZSBmcm9udGVuZCBzdG9yZVxuICB8ICdjb21wbGV0ZWQnICAgICAgICAgICAvLyDinIUgSW5nZXN0aW9uIGZpbmlzaGVkLCBVSSByZWZyZXNoZWRcbiAgfCAnZXJyb3InOyAgICAgICAgICAgICAgLy8g8J+UtCBTY3JhcGUgb3IgaW5nZXN0aW9uIGZhaWxlZFxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyZXNzU3RhdGVDb25maWcge1xuICBsYWJlbDogc3RyaW5nO1xuICBpY29uOiBzdHJpbmc7XG4gIGNvbG9yOiBzdHJpbmc7XG4gIGJnQ29sb3I6IHN0cmluZztcbiAgYm9yZGVyQ29sb3I6IHN0cmluZztcbiAgYW5pbWF0aW9uPzogJ3B1bHNlJyB8ICdzcGluJyB8ICdmYWRlJyB8ICdub25lJztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IFBST0dSRVNTX1NUQVRFX0NPTkZJRzogUmVjb3JkPFByb2dyZXNzU3RhdGUsIFByb2dyZXNzU3RhdGVDb25maWc+ID0ge1xuICByZWFkeToge1xuICAgIGxhYmVsOiAnUmVhZHknLFxuICAgIGljb246ICfwn5+iJyxcbiAgICBjb2xvcjogJ3ZhcigtLWNvbG9yLXRleHQtbXV0ZWQpJyxcbiAgICBiZ0NvbG9yOiAndmFyKC0tY29sb3Itc3VyZmFjZS1lbGV2YXRlZCknLFxuICAgIGJvcmRlckNvbG9yOiAndmFyKC0tY29sb3ItYm9yZGVyKScsXG4gICAgYW5pbWF0aW9uOiAnbm9uZScsXG4gICAgZGVzY3JpcHRpb246ICdJZGxlLCB3YWl0aW5nIGZvciB1c2VyIGlucHV0JyxcbiAgfSxcbiAgc2NyYXBlX2luaXRpYXRlZDoge1xuICAgIGxhYmVsOiAnU2NyYXBlIEluaXRpYXRlZCcsXG4gICAgaWNvbjogJ/Cfn6EnLFxuICAgIGNvbG9yOiAndmFyKC0tY29sb3ItcHJpbWFyeSknLFxuICAgIGJnQ29sb3I6ICdyZ2JhKDAsIDE1OSwgNjEsIDAuMiknLCAvLyAjMDA5RjNEIHdpdGggb3BhY2l0eVxuICAgIGJvcmRlckNvbG9yOiAncmdiYSgwLCAxNTksIDYxLCAwLjMpJyxcbiAgICBhbmltYXRpb246ICdwdWxzZScsXG4gICAgZGVzY3JpcHRpb246ICdVc2VyIHRyaWdnZXJlZCBtYW51YWwgc2NyYXBlJyxcbiAgfSxcbiAgc2NyYXBpbmc6IHtcbiAgICBsYWJlbDogJ1NjcmFwaW5nJyxcbiAgICBpY29uOiAn8J+foCcsXG4gICAgY29sb3I6ICd2YXIoLS1jb2xvci1wcmltYXJ5KScsXG4gICAgYmdDb2xvcjogJ3JnYmEoMCwgMTU5LCA2MSwgMC4yKScsIC8vICMwMDlGM0Qgd2l0aCBvcGFjaXR5XG4gICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDAsIDE1OSwgNjEsIDAuMyknLFxuICAgIGFuaW1hdGlvbjogJ3NwaW4nLFxuICAgIGRlc2NyaXB0aW9uOiAnQXBpZnkgcnVuIGluIHByb2dyZXNzJyxcbiAgfSxcbiAgcHJvY2Vzc2luZzoge1xuICAgIGxhYmVsOiAnUHJvY2Vzc2luZycsXG4gICAgaWNvbjogJ/Cfn6MnLFxuICAgIGNvbG9yOiAnI2E3OGJmYScsXG4gICAgYmdDb2xvcjogJ3JnYmEoMTY3LCAxMzksIDI1MCwgMC4yKScsXG4gICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDE2NywgMTM5LCAyNTAsIDAuMyknLFxuICAgIGFuaW1hdGlvbjogJ3NwaW4nLFxuICAgIGRlc2NyaXB0aW9uOiAnRGF0YSByZXRyaWV2ZWQsIHBhcnNpbmcgb3IgdHJhbnNmb3JtaW5nJyxcbiAgfSxcbiAgaW5nZXN0aW5nOiB7XG4gICAgbGFiZWw6ICdJbmdlc3RpbmcnLFxuICAgIGljb246ICfwn5+pJyxcbiAgICBjb2xvcjogJ3ZhcigtLWNvbG9yLXN1Y2Nlc3MpJyxcbiAgICBiZ0NvbG9yOiAncmdiYSgzNCwgMTk3LCA5NCwgMC4yKScsXG4gICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDM0LCAxOTcsIDk0LCAwLjMpJyxcbiAgICBhbmltYXRpb246ICdzcGluJyxcbiAgICBkZXNjcmlwdGlvbjogJ0RhdGFiYXNlIGluc2VydCBvciB1cGRhdGUgcnVubmluZycsXG4gIH0sXG4gIHVwZGF0aW5nX3VpOiB7XG4gICAgbGFiZWw6ICdVcGRhdGluZyBVSScsXG4gICAgaWNvbjogJ/Cfn6YnLFxuICAgIGNvbG9yOiAndmFyKC0tY29sb3ItaW5mbyknLFxuICAgIGJnQ29sb3I6ICdyZ2JhKDU5LCAxMzAsIDI0NiwgMC4yKScsXG4gICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDU5LCAxMzAsIDI0NiwgMC4zKScsXG4gICAgYW5pbWF0aW9uOiAnZmFkZScsXG4gICAgZGVzY3JpcHRpb246ICdOZXcgZGF0YSBiZWluZyBwdXNoZWQgdG8gdGhlIGZyb250ZW5kIHN0b3JlJyxcbiAgfSxcbiAgY29tcGxldGVkOiB7XG4gICAgbGFiZWw6ICdDb21wbGV0ZWQnLFxuICAgIGljb246ICfinIUnLFxuICAgIGNvbG9yOiAndmFyKC0tY29sb3Itc3VjY2VzcyknLFxuICAgIGJnQ29sb3I6ICdyZ2JhKDM0LCAxOTcsIDk0LCAwLjIpJyxcbiAgICBib3JkZXJDb2xvcjogJ3JnYmEoMzQsIDE5NywgOTQsIDAuMyknLFxuICAgIGFuaW1hdGlvbjogJ2ZhZGUnLFxuICAgIGRlc2NyaXB0aW9uOiAnSW5nZXN0aW9uIGZpbmlzaGVkLCBVSSByZWZyZXNoZWQnLFxuICB9LFxuICBlcnJvcjoge1xuICAgIGxhYmVsOiAnRXJyb3InLFxuICAgIGljb246ICfwn5S0JyxcbiAgICBjb2xvcjogJ3ZhcigtLWNvbG9yLWVycm9yKScsXG4gICAgYmdDb2xvcjogJ3JnYmEoMjM5LCA2OCwgNjgsIDAuMiknLFxuICAgIGJvcmRlckNvbG9yOiAncmdiYSgyMzksIDY4LCA2OCwgMC4zKScsXG4gICAgYW5pbWF0aW9uOiAnbm9uZScsXG4gICAgZGVzY3JpcHRpb246ICdTY3JhcGUgb3IgaW5nZXN0aW9uIGZhaWxlZCcsXG4gIH0sXG59O1xuXG4vKipcbiAqIERldGVybWluZSBwcm9ncmVzcyBzdGF0ZSBmcm9tIGJhY2tlbmQgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5lUHJvZ3Jlc3NTdGF0ZShcbiAgc2NyYXBlU3RhdHVzOiAncGVuZGluZycgfCAncnVubmluZycgfCAnY29tcGxldGVkJyB8ICdmYWlsZWQnIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgbGFzdFNjcmFwZWRBdDogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgaXNTY3JhcGluZzogYm9vbGVhbixcbiAgam9iU3RhdHVzZXM/OiB7XG4gICAgJ3Jvb21zLXNjcmFwZXInPzogeyBzdGF0dXM6IHN0cmluZyB9O1xuICAgICdyZXZpZXdzLXNjcmFwZXInPzogeyBzdGF0dXM6IHN0cmluZyB9O1xuICAgICdpbmdlc3Rpb24nPzogeyBzdGF0dXM6IHN0cmluZyB9O1xuICB9XG4pOiBQcm9ncmVzc1N0YXRlIHtcbiAgLy8gRXJyb3Igc3RhdGUgdGFrZXMgcHJpb3JpdHlcbiAgaWYgKHNjcmFwZVN0YXR1cyA9PT0gJ2ZhaWxlZCcpIHtcbiAgICByZXR1cm4gJ2Vycm9yJztcbiAgfVxuXG4gIC8vIEhJR0hFU1QgUFJJT1JJVFk6IElmIHNjcmFwZV9zdGF0dXMgaXMgY29tcGxldGVkLCBhbHdheXMgc2hvdyBjb21wbGV0ZWRcbiAgaWYgKHNjcmFwZVN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcpIHtcbiAgICByZXR1cm4gJ2NvbXBsZXRlZCc7XG4gIH1cblxuICAvLyBDaGVjayBqb2Igc3RhdHVzZXMgZm9yIG1vcmUgZ3JhbnVsYXIgc3RhdGVcbiAgaWYgKGpvYlN0YXR1c2VzKSB7XG4gICAgY29uc3QgaW5nZXN0aW9uU3RhdHVzID0gam9iU3RhdHVzZXNbJ2luZ2VzdGlvbiddPy5zdGF0dXM7XG4gICAgY29uc3QgcmV2aWV3c1N0YXR1cyA9IGpvYlN0YXR1c2VzWydyZXZpZXdzLXNjcmFwZXInXT8uc3RhdHVzO1xuICAgIGNvbnN0IHJvb21zU3RhdHVzID0gam9iU3RhdHVzZXNbJ3Jvb21zLXNjcmFwZXInXT8uc3RhdHVzO1xuXG4gICAgLy8gSWYgaW5nZXN0aW9uIGlzIGNvbXBsZXRlZCwgd2UncmUgZG9uZVxuICAgIGlmIChpbmdlc3Rpb25TdGF0dXMgPT09ICdjb21wbGV0ZWQnKSB7XG4gICAgICByZXR1cm4gJ2NvbXBsZXRlZCc7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIGluZ2VzdGlvbiBpcyBydW5uaW5nLCBzaG93IGluZ2VzdGluZ1xuICAgIGlmIChpbmdlc3Rpb25TdGF0dXMgPT09ICdydW5uaW5nJykge1xuICAgICAgcmV0dXJuICdpbmdlc3RpbmcnO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiByZXZpZXdzIHNjcmFwZXIgaXMgcnVubmluZywgc2hvdyBwcm9jZXNzaW5nXG4gICAgaWYgKHJldmlld3NTdGF0dXMgPT09ICdydW5uaW5nJykge1xuICAgICAgcmV0dXJuICdwcm9jZXNzaW5nJztcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgcm9vbXMgc2NyYXBlciBpcyBydW5uaW5nLCBzaG93IHNjcmFwaW5nXG4gICAgaWYgKHJvb21zU3RhdHVzID09PSAncnVubmluZycpIHtcbiAgICAgIHJldHVybiAnc2NyYXBpbmcnO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiBhbGwgam9icyBhcmUgY29tcGxldGVkIChvciBubyBqb2JzIGV4aXN0KSwgY2hlY2sgc2NyYXBlX3N0YXR1c1xuICAgIGNvbnN0IGFsbEpvYnNDb21wbGV0ZWQgPSAoXG4gICAgICAoIXJvb21zU3RhdHVzIHx8IHJvb21zU3RhdHVzID09PSAnY29tcGxldGVkJyB8fCByb29tc1N0YXR1cyA9PT0gJ2ZhaWxlZCcpICYmXG4gICAgICAoIXJldmlld3NTdGF0dXMgfHwgcmV2aWV3c1N0YXR1cyA9PT0gJ2NvbXBsZXRlZCcgfHwgcmV2aWV3c1N0YXR1cyA9PT0gJ2ZhaWxlZCcpICYmXG4gICAgICAoIWluZ2VzdGlvblN0YXR1cyB8fCBpbmdlc3Rpb25TdGF0dXMgPT09ICdjb21wbGV0ZWQnIHx8IGluZ2VzdGlvblN0YXR1cyA9PT0gJ2ZhaWxlZCcpXG4gICAgKTtcbiAgICBcbiAgICBpZiAoYWxsSm9ic0NvbXBsZXRlZCAmJiBsYXN0U2NyYXBlZEF0KSB7XG4gICAgICByZXR1cm4gJ2NvbXBsZXRlZCc7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgYWN0aXZlbHkgc2NyYXBpbmcgKGZyb250ZW5kIHN0YXRlKSwgc2hvdyBzY3JhcGluZ1xuICBpZiAoaXNTY3JhcGluZykge1xuICAgIHJldHVybiAnc2NyYXBpbmcnO1xuICB9XG5cbiAgLy8gSWYgc3RhdHVzIGlzIHJ1bm5pbmcgYW5kIHdlIGhhdmUgbGFzdF9zY3JhcGVkX2F0LCBjaGVjayBpZiBqb2JzIGFyZSBkb25lXG4gIGlmIChzY3JhcGVTdGF0dXMgPT09ICdydW5uaW5nJyAmJiBsYXN0U2NyYXBlZEF0ICYmICFpc1NjcmFwaW5nKSB7XG4gICAgaWYgKGpvYlN0YXR1c2VzKSB7XG4gICAgICBjb25zdCBhbGxKb2JzRG9uZSA9IChcbiAgICAgICAgKCFqb2JTdGF0dXNlc1sncm9vbXMtc2NyYXBlciddIHx8IGpvYlN0YXR1c2VzWydyb29tcy1zY3JhcGVyJ10uc3RhdHVzID09PSAnY29tcGxldGVkJyB8fCBqb2JTdGF0dXNlc1sncm9vbXMtc2NyYXBlciddLnN0YXR1cyA9PT0gJ2ZhaWxlZCcpICYmXG4gICAgICAgICgham9iU3RhdHVzZXNbJ3Jldmlld3Mtc2NyYXBlciddIHx8IGpvYlN0YXR1c2VzWydyZXZpZXdzLXNjcmFwZXInXS5zdGF0dXMgPT09ICdjb21wbGV0ZWQnIHx8IGpvYlN0YXR1c2VzWydyZXZpZXdzLXNjcmFwZXInXS5zdGF0dXMgPT09ICdmYWlsZWQnKSAmJlxuICAgICAgICAoIWpvYlN0YXR1c2VzWydpbmdlc3Rpb24nXSB8fCBqb2JTdGF0dXNlc1snaW5nZXN0aW9uJ10uc3RhdHVzID09PSAnY29tcGxldGVkJyB8fCBqb2JTdGF0dXNlc1snaW5nZXN0aW9uJ10uc3RhdHVzID09PSAnZmFpbGVkJylcbiAgICAgICk7XG4gICAgICBpZiAoYWxsSm9ic0RvbmUpIHtcbiAgICAgICAgcmV0dXJuICdjb21wbGV0ZWQnO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiBzY3JhcGUgd2FzIG1vcmUgdGhhbiAyMCBtaW51dGVzIGFnbyBhbmQgd2UncmUgbm90IGFjdGl2ZWx5IHNjcmFwaW5nLCBhc3N1bWUgY29tcGxldGVkXG4gICAgY29uc3QgbGFzdFNjcmFwZWQgPSBuZXcgRGF0ZShsYXN0U2NyYXBlZEF0KTtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IG1pbnV0ZXNTaW5jZVNjcmFwZSA9IChub3cuZ2V0VGltZSgpIC0gbGFzdFNjcmFwZWQuZ2V0VGltZSgpKSAvICgxMDAwICogNjApO1xuICAgIGlmIChtaW51dGVzU2luY2VTY3JhcGUgPiAyMCkge1xuICAgICAgcmV0dXJuICdjb21wbGV0ZWQnO1xuICAgIH1cbiAgICByZXR1cm4gJ3NjcmFwaW5nJztcbiAgfVxuXG4gIC8vIElmIHN0YXR1cyBpcyBydW5uaW5nIGFuZCB3ZSdyZSBhY3RpdmVseSBzY3JhcGluZywgc2hvdyBzY3JhcGluZ1xuICBpZiAoc2NyYXBlU3RhdHVzID09PSAncnVubmluZycpIHtcbiAgICByZXR1cm4gJ3NjcmFwaW5nJztcbiAgfVxuXG4gIGlmIChzY3JhcGVTdGF0dXMgPT09ICdwZW5kaW5nJyB8fCAhbGFzdFNjcmFwZWRBdCkge1xuICAgIHJldHVybiAncmVhZHknO1xuICB9XG5cbiAgLy8gRGVmYXVsdDogaWYgd2UgaGF2ZSBsYXN0X3NjcmFwZWRfYXQgYnV0IG5vIGNsZWFyIHN0YXR1cywgYXNzdW1lIGNvbXBsZXRlZFxuICByZXR1cm4gJ2NvbXBsZXRlZCc7XG59XG5cbi8qKlxuICogR2V0IGFuaW1hdGlvbiBjbGFzcyBmb3IgYSBwcm9ncmVzcyBzdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QW5pbWF0aW9uQ2xhc3Moc3RhdGU6IFByb2dyZXNzU3RhdGUpOiBzdHJpbmcge1xuICBjb25zdCBjb25maWcgPSBQUk9HUkVTU19TVEFURV9DT05GSUdbc3RhdGVdO1xuICBpZiAoIWNvbmZpZy5hbmltYXRpb24gfHwgY29uZmlnLmFuaW1hdGlvbiA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgc3dpdGNoIChjb25maWcuYW5pbWF0aW9uKSB7XG4gICAgY2FzZSAncHVsc2UnOlxuICAgICAgcmV0dXJuICdhbmltYXRlLXB1bHNlJztcbiAgICBjYXNlICdzcGluJzpcbiAgICAgIHJldHVybiAnYW5pbWF0ZS1zcGluJztcbiAgICBjYXNlICdmYWRlJzpcbiAgICAgIHJldHVybiAnb3BhY2l0eS03NSc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG4iXSwibmFtZXMiOlsiUFJPR1JFU1NfU1RBVEVfQ09ORklHIiwicmVhZHkiLCJsYWJlbCIsImljb24iLCJjb2xvciIsImJnQ29sb3IiLCJib3JkZXJDb2xvciIsImFuaW1hdGlvbiIsImRlc2NyaXB0aW9uIiwic2NyYXBlX2luaXRpYXRlZCIsInNjcmFwaW5nIiwicHJvY2Vzc2luZyIsImluZ2VzdGluZyIsInVwZGF0aW5nX3VpIiwiY29tcGxldGVkIiwiZXJyb3IiLCJkZXRlcm1pbmVQcm9ncmVzc1N0YXRlIiwic2NyYXBlU3RhdHVzIiwibGFzdFNjcmFwZWRBdCIsImlzU2NyYXBpbmciLCJqb2JTdGF0dXNlcyIsImluZ2VzdGlvblN0YXR1cyIsInN0YXR1cyIsInJldmlld3NTdGF0dXMiLCJyb29tc1N0YXR1cyIsImFsbEpvYnNDb21wbGV0ZWQiLCJhbGxKb2JzRG9uZSIsImxhc3RTY3JhcGVkIiwiRGF0ZSIsIm5vdyIsIm1pbnV0ZXNTaW5jZVNjcmFwZSIsImdldFRpbWUiLCJnZXRBbmltYXRpb25DbGFzcyIsInN0YXRlIiwiY29uZmlnIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/progressStates.ts\n"));

/***/ })

});