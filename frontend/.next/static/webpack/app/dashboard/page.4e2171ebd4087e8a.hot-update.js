"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./lib/progressStates.ts":
/*!*******************************!*\
  !*** ./lib/progressStates.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PROGRESS_STATE_CONFIG: function() { return /* binding */ PROGRESS_STATE_CONFIG; },\n/* harmony export */   determineProgressState: function() { return /* binding */ determineProgressState; },\n/* harmony export */   getAnimationClass: function() { return /* binding */ getAnimationClass; }\n/* harmony export */ });\n/**\n * Unified progress state model for scraping and ingestion workflow\n * \n * This provides a clear state machine that maps backend events to user-visible states\n */ const PROGRESS_STATE_CONFIG = {\n    ready: {\n        label: \"Ready\",\n        icon: \"\\uD83D\\uDFE2\",\n        color: \"var(--color-text-muted)\",\n        bgColor: \"var(--color-surface-elevated)\",\n        borderColor: \"var(--color-border)\",\n        animation: \"none\",\n        description: \"Idle, waiting for user input\"\n    },\n    scrape_initiated: {\n        label: \"Scrape Initiated\",\n        icon: \"\\uD83D\\uDFE1\",\n        color: \"var(--color-primary)\",\n        bgColor: \"rgba(0, 128, 0, 0.2)\",\n        borderColor: \"rgba(0, 128, 0, 0.3)\",\n        animation: \"pulse\",\n        description: \"User triggered manual scrape\"\n    },\n    scraping: {\n        label: \"Scraping\",\n        icon: \"\\uD83D\\uDFE0\",\n        color: \"var(--color-primary)\",\n        bgColor: \"rgba(0, 128, 0, 0.2)\",\n        borderColor: \"rgba(0, 128, 0, 0.3)\",\n        animation: \"spin\",\n        description: \"Apify run in progress\"\n    },\n    processing: {\n        label: \"Processing\",\n        icon: \"\\uD83D\\uDFE3\",\n        color: \"#a78bfa\",\n        bgColor: \"rgba(167, 139, 250, 0.2)\",\n        borderColor: \"rgba(167, 139, 250, 0.3)\",\n        animation: \"spin\",\n        description: \"Data retrieved, parsing or transforming\"\n    },\n    ingesting: {\n        label: \"Ingesting\",\n        icon: \"\\uD83D\\uDFE9\",\n        color: \"var(--color-success)\",\n        bgColor: \"rgba(34, 197, 94, 0.2)\",\n        borderColor: \"rgba(34, 197, 94, 0.3)\",\n        animation: \"spin\",\n        description: \"Database insert or update running\"\n    },\n    updating_ui: {\n        label: \"Updating UI\",\n        icon: \"\\uD83D\\uDFE6\",\n        color: \"var(--color-info)\",\n        bgColor: \"rgba(59, 130, 246, 0.2)\",\n        borderColor: \"rgba(59, 130, 246, 0.3)\",\n        animation: \"fade\",\n        description: \"New data being pushed to the frontend store\"\n    },\n    completed: {\n        label: \"Completed\",\n        icon: \"âœ…\",\n        color: \"var(--color-success)\",\n        bgColor: \"rgba(34, 197, 94, 0.2)\",\n        borderColor: \"rgba(34, 197, 94, 0.3)\",\n        animation: \"fade\",\n        description: \"Ingestion finished, UI refreshed\"\n    },\n    error: {\n        label: \"Error\",\n        icon: \"\\uD83D\\uDD34\",\n        color: \"var(--color-error)\",\n        bgColor: \"rgba(239, 68, 68, 0.2)\",\n        borderColor: \"rgba(239, 68, 68, 0.3)\",\n        animation: \"none\",\n        description: \"Scrape or ingestion failed\"\n    }\n};\n/**\n * Determine progress state from backend data\n */ function determineProgressState(scrapeStatus, lastScrapedAt, isScraping, jobStatuses) {\n    // Error state takes priority\n    if (scrapeStatus === \"failed\") {\n        return \"error\";\n    }\n    // HIGHEST PRIORITY: If scrape_status is completed, always show completed\n    if (scrapeStatus === \"completed\") {\n        return \"completed\";\n    }\n    // Check job statuses for more granular state\n    if (jobStatuses) {\n        var _jobStatuses_ingestion, _jobStatuses_reviewsscraper, _jobStatuses_roomsscraper;\n        const ingestionStatus = (_jobStatuses_ingestion = jobStatuses[\"ingestion\"]) === null || _jobStatuses_ingestion === void 0 ? void 0 : _jobStatuses_ingestion.status;\n        const reviewsStatus = (_jobStatuses_reviewsscraper = jobStatuses[\"reviews-scraper\"]) === null || _jobStatuses_reviewsscraper === void 0 ? void 0 : _jobStatuses_reviewsscraper.status;\n        const roomsStatus = (_jobStatuses_roomsscraper = jobStatuses[\"rooms-scraper\"]) === null || _jobStatuses_roomsscraper === void 0 ? void 0 : _jobStatuses_roomsscraper.status;\n        // If ingestion is completed, we're done\n        if (ingestionStatus === \"completed\") {\n            return \"completed\";\n        }\n        // If ingestion is running, show ingesting\n        if (ingestionStatus === \"running\") {\n            return \"ingesting\";\n        }\n        // If reviews scraper is running, show processing\n        if (reviewsStatus === \"running\") {\n            return \"processing\";\n        }\n        // If rooms scraper is running, show scraping\n        if (roomsStatus === \"running\") {\n            return \"scraping\";\n        }\n        // If all jobs are completed (or no jobs exist), check scrape_status\n        const allJobsCompleted = (!roomsStatus || roomsStatus === \"completed\" || roomsStatus === \"failed\") && (!reviewsStatus || reviewsStatus === \"completed\" || reviewsStatus === \"failed\") && (!ingestionStatus || ingestionStatus === \"completed\" || ingestionStatus === \"failed\");\n        if (allJobsCompleted && lastScrapedAt) {\n            return \"completed\";\n        }\n    }\n    // If actively scraping (frontend state), show scraping\n    if (isScraping) {\n        return \"scraping\";\n    }\n    // If status is running and we have last_scraped_at, check if jobs are done\n    if (scrapeStatus === \"running\" && lastScrapedAt && !isScraping) {\n        if (jobStatuses) {\n            const allJobsDone = (!jobStatuses[\"rooms-scraper\"] || jobStatuses[\"rooms-scraper\"].status === \"completed\" || jobStatuses[\"rooms-scraper\"].status === \"failed\") && (!jobStatuses[\"reviews-scraper\"] || jobStatuses[\"reviews-scraper\"].status === \"completed\" || jobStatuses[\"reviews-scraper\"].status === \"failed\") && (!jobStatuses[\"ingestion\"] || jobStatuses[\"ingestion\"].status === \"completed\" || jobStatuses[\"ingestion\"].status === \"failed\");\n            if (allJobsDone) {\n                return \"completed\";\n            }\n        }\n        // If scrape was more than 20 minutes ago and we're not actively scraping, assume completed\n        const lastScraped = new Date(lastScrapedAt);\n        const now = new Date();\n        const minutesSinceScrape = (now.getTime() - lastScraped.getTime()) / (1000 * 60);\n        if (minutesSinceScrape > 20) {\n            return \"completed\";\n        }\n        return \"scraping\";\n    }\n    // If status is running and we're actively scraping, show scraping\n    if (scrapeStatus === \"running\") {\n        return \"scraping\";\n    }\n    if (scrapeStatus === \"pending\" || !lastScrapedAt) {\n        return \"ready\";\n    }\n    // Default: if we have last_scraped_at but no clear status, assume completed\n    return \"completed\";\n}\n/**\n * Get animation class for a progress state\n */ function getAnimationClass(state) {\n    const config = PROGRESS_STATE_CONFIG[state];\n    if (!config.animation || config.animation === \"none\") {\n        return \"\";\n    }\n    switch(config.animation){\n        case \"pulse\":\n            return \"animate-pulse\";\n        case \"spin\":\n            return \"animate-spin\";\n        case \"fade\":\n            return \"opacity-75\";\n        default:\n            return \"\";\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9wcm9ncmVzc1N0YXRlcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7OztDQUlDLEdBc0JNLE1BQU1BLHdCQUFvRTtJQUMvRUMsT0FBTztRQUNMQyxPQUFPO1FBQ1BDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxhQUFhO0lBQ2Y7SUFDQUMsa0JBQWtCO1FBQ2hCUCxPQUFPO1FBQ1BDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxhQUFhO0lBQ2Y7SUFDQUUsVUFBVTtRQUNSUixPQUFPO1FBQ1BDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxhQUFhO0lBQ2Y7SUFDQUcsWUFBWTtRQUNWVCxPQUFPO1FBQ1BDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxhQUFhO0lBQ2Y7SUFDQUksV0FBVztRQUNUVixPQUFPO1FBQ1BDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxhQUFhO0lBQ2Y7SUFDQUssYUFBYTtRQUNYWCxPQUFPO1FBQ1BDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxhQUFhO0lBQ2Y7SUFDQU0sV0FBVztRQUNUWixPQUFPO1FBQ1BDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxhQUFhO0lBQ2Y7SUFDQU8sT0FBTztRQUNMYixPQUFPO1FBQ1BDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLGFBQWE7UUFDYkMsV0FBVztRQUNYQyxhQUFhO0lBQ2Y7QUFDRixFQUFFO0FBRUY7O0NBRUMsR0FDTSxTQUFTUSx1QkFD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T0FBUTJCLE9BQU8zQixTQUFTO1FBQ3RCLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNUO1lBQ0UsT0FBTztJQUNYO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3Byb2dyZXNzU3RhdGVzLnRzPzcyODYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVbmlmaWVkIHByb2dyZXNzIHN0YXRlIG1vZGVsIGZvciBzY3JhcGluZyBhbmQgaW5nZXN0aW9uIHdvcmtmbG93XG4gKiBcbiAqIFRoaXMgcHJvdmlkZXMgYSBjbGVhciBzdGF0ZSBtYWNoaW5lIHRoYXQgbWFwcyBiYWNrZW5kIGV2ZW50cyB0byB1c2VyLXZpc2libGUgc3RhdGVzXG4gKi9cblxuZXhwb3J0IHR5cGUgUHJvZ3Jlc3NTdGF0ZSA9XG4gIHwgJ3JlYWR5JyAgICAgICAgICAgICAgLy8g8J+foiBJZGxlLCB3YWl0aW5nIGZvciB1c2VyIGlucHV0XG4gIHwgJ3NjcmFwZV9pbml0aWF0ZWQnICAgLy8g8J+foSBVc2VyIHRyaWdnZXJlZCBtYW51YWwgc2NyYXBlXG4gIHwgJ3NjcmFwaW5nJyAgICAgICAgICAgIC8vIPCfn6AgQXBpZnkgcnVuIGluIHByb2dyZXNzXG4gIHwgJ3Byb2Nlc3NpbmcnICAgICAgICAgIC8vIPCfn6MgRGF0YSByZXRyaWV2ZWQsIHBhcnNpbmcgb3IgdHJhbnNmb3JtaW5nXG4gIHwgJ2luZ2VzdGluZycgICAgICAgICAgIC8vIPCfn6kgRGF0YWJhc2UgaW5zZXJ0IG9yIHVwZGF0ZSBydW5uaW5nXG4gIHwgJ3VwZGF0aW5nX3VpJyAgICAgICAgIC8vIPCfn6YgTmV3IGRhdGEgYmVpbmcgcHVzaGVkIHRvIHRoZSBmcm9udGVuZCBzdG9yZVxuICB8ICdjb21wbGV0ZWQnICAgICAgICAgICAvLyDinIUgSW5nZXN0aW9uIGZpbmlzaGVkLCBVSSByZWZyZXNoZWRcbiAgfCAnZXJyb3InOyAgICAgICAgICAgICAgLy8g8J+UtCBTY3JhcGUgb3IgaW5nZXN0aW9uIGZhaWxlZFxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyZXNzU3RhdGVDb25maWcge1xuICBsYWJlbDogc3RyaW5nO1xuICBpY29uOiBzdHJpbmc7XG4gIGNvbG9yOiBzdHJpbmc7XG4gIGJnQ29sb3I6IHN0cmluZztcbiAgYm9yZGVyQ29sb3I6IHN0cmluZztcbiAgYW5pbWF0aW9uPzogJ3B1bHNlJyB8ICdzcGluJyB8ICdmYWRlJyB8ICdub25lJztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IFBST0dSRVNTX1NUQVRFX0NPTkZJRzogUmVjb3JkPFByb2dyZXNzU3RhdGUsIFByb2dyZXNzU3RhdGVDb25maWc+ID0ge1xuICByZWFkeToge1xuICAgIGxhYmVsOiAnUmVhZHknLFxuICAgIGljb246ICfwn5+iJyxcbiAgICBjb2xvcjogJ3ZhcigtLWNvbG9yLXRleHQtbXV0ZWQpJyxcbiAgICBiZ0NvbG9yOiAndmFyKC0tY29sb3Itc3VyZmFjZS1lbGV2YXRlZCknLFxuICAgIGJvcmRlckNvbG9yOiAndmFyKC0tY29sb3ItYm9yZGVyKScsXG4gICAgYW5pbWF0aW9uOiAnbm9uZScsXG4gICAgZGVzY3JpcHRpb246ICdJZGxlLCB3YWl0aW5nIGZvciB1c2VyIGlucHV0JyxcbiAgfSxcbiAgc2NyYXBlX2luaXRpYXRlZDoge1xuICAgIGxhYmVsOiAnU2NyYXBlIEluaXRpYXRlZCcsXG4gICAgaWNvbjogJ/Cfn6EnLFxuICAgIGNvbG9yOiAndmFyKC0tY29sb3ItcHJpbWFyeSknLFxuICAgIGJnQ29sb3I6ICdyZ2JhKDAsIDEyOCwgMCwgMC4yKScsIC8vIFVzaW5nIGdyZWVuIHByaW1hcnkgY29sb3Igd2l0aCBvcGFjaXR5XG4gICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDAsIDEyOCwgMCwgMC4zKScsXG4gICAgYW5pbWF0aW9uOiAncHVsc2UnLFxuICAgIGRlc2NyaXB0aW9uOiAnVXNlciB0cmlnZ2VyZWQgbWFudWFsIHNjcmFwZScsXG4gIH0sXG4gIHNjcmFwaW5nOiB7XG4gICAgbGFiZWw6ICdTY3JhcGluZycsXG4gICAgaWNvbjogJ/Cfn6AnLFxuICAgIGNvbG9yOiAndmFyKC0tY29sb3ItcHJpbWFyeSknLFxuICAgIGJnQ29sb3I6ICdyZ2JhKDAsIDEyOCwgMCwgMC4yKScsIC8vIFVzaW5nIGdyZWVuIHByaW1hcnkgY29sb3Igd2l0aCBvcGFjaXR5XG4gICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDAsIDEyOCwgMCwgMC4zKScsXG4gICAgYW5pbWF0aW9uOiAnc3BpbicsXG4gICAgZGVzY3JpcHRpb246ICdBcGlmeSBydW4gaW4gcHJvZ3Jlc3MnLFxuICB9LFxuICBwcm9jZXNzaW5nOiB7XG4gICAgbGFiZWw6ICdQcm9jZXNzaW5nJyxcbiAgICBpY29uOiAn8J+foycsXG4gICAgY29sb3I6ICcjYTc4YmZhJyxcbiAgICBiZ0NvbG9yOiAncmdiYSgxNjcsIDEzOSwgMjUwLCAwLjIpJyxcbiAgICBib3JkZXJDb2xvcjogJ3JnYmEoMTY3LCAxMzksIDI1MCwgMC4zKScsXG4gICAgYW5pbWF0aW9uOiAnc3BpbicsXG4gICAgZGVzY3JpcHRpb246ICdEYXRhIHJldHJpZXZlZCwgcGFyc2luZyBvciB0cmFuc2Zvcm1pbmcnLFxuICB9LFxuICBpbmdlc3Rpbmc6IHtcbiAgICBsYWJlbDogJ0luZ2VzdGluZycsXG4gICAgaWNvbjogJ/Cfn6knLFxuICAgIGNvbG9yOiAndmFyKC0tY29sb3Itc3VjY2VzcyknLFxuICAgIGJnQ29sb3I6ICdyZ2JhKDM0LCAxOTcsIDk0LCAwLjIpJyxcbiAgICBib3JkZXJDb2xvcjogJ3JnYmEoMzQsIDE5NywgOTQsIDAuMyknLFxuICAgIGFuaW1hdGlvbjogJ3NwaW4nLFxuICAgIGRlc2NyaXB0aW9uOiAnRGF0YWJhc2UgaW5zZXJ0IG9yIHVwZGF0ZSBydW5uaW5nJyxcbiAgfSxcbiAgdXBkYXRpbmdfdWk6IHtcbiAgICBsYWJlbDogJ1VwZGF0aW5nIFVJJyxcbiAgICBpY29uOiAn8J+fpicsXG4gICAgY29sb3I6ICd2YXIoLS1jb2xvci1pbmZvKScsXG4gICAgYmdDb2xvcjogJ3JnYmEoNTksIDEzMCwgMjQ2LCAwLjIpJyxcbiAgICBib3JkZXJDb2xvcjogJ3JnYmEoNTksIDEzMCwgMjQ2LCAwLjMpJyxcbiAgICBhbmltYXRpb246ICdmYWRlJyxcbiAgICBkZXNjcmlwdGlvbjogJ05ldyBkYXRhIGJlaW5nIHB1c2hlZCB0byB0aGUgZnJvbnRlbmQgc3RvcmUnLFxuICB9LFxuICBjb21wbGV0ZWQ6IHtcbiAgICBsYWJlbDogJ0NvbXBsZXRlZCcsXG4gICAgaWNvbjogJ+KchScsXG4gICAgY29sb3I6ICd2YXIoLS1jb2xvci1zdWNjZXNzKScsXG4gICAgYmdDb2xvcjogJ3JnYmEoMzQsIDE5NywgOTQsIDAuMiknLFxuICAgIGJvcmRlckNvbG9yOiAncmdiYSgzNCwgMTk3LCA5NCwgMC4zKScsXG4gICAgYW5pbWF0aW9uOiAnZmFkZScsXG4gICAgZGVzY3JpcHRpb246ICdJbmdlc3Rpb24gZmluaXNoZWQsIFVJIHJlZnJlc2hlZCcsXG4gIH0sXG4gIGVycm9yOiB7XG4gICAgbGFiZWw6ICdFcnJvcicsXG4gICAgaWNvbjogJ/CflLQnLFxuICAgIGNvbG9yOiAndmFyKC0tY29sb3ItZXJyb3IpJyxcbiAgICBiZ0NvbG9yOiAncmdiYSgyMzksIDY4LCA2OCwgMC4yKScsXG4gICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDIzOSwgNjgsIDY4LCAwLjMpJyxcbiAgICBhbmltYXRpb246ICdub25lJyxcbiAgICBkZXNjcmlwdGlvbjogJ1NjcmFwZSBvciBpbmdlc3Rpb24gZmFpbGVkJyxcbiAgfSxcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHByb2dyZXNzIHN0YXRlIGZyb20gYmFja2VuZCBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmVQcm9ncmVzc1N0YXRlKFxuICBzY3JhcGVTdGF0dXM6ICdwZW5kaW5nJyB8ICdydW5uaW5nJyB8ICdjb21wbGV0ZWQnIHwgJ2ZhaWxlZCcgfCBudWxsIHwgdW5kZWZpbmVkLFxuICBsYXN0U2NyYXBlZEF0OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkLFxuICBpc1NjcmFwaW5nOiBib29sZWFuLFxuICBqb2JTdGF0dXNlcz86IHtcbiAgICAncm9vbXMtc2NyYXBlcic/OiB7IHN0YXR1czogc3RyaW5nIH07XG4gICAgJ3Jldmlld3Mtc2NyYXBlcic/OiB7IHN0YXR1czogc3RyaW5nIH07XG4gICAgJ2luZ2VzdGlvbic/OiB7IHN0YXR1czogc3RyaW5nIH07XG4gIH1cbik6IFByb2dyZXNzU3RhdGUge1xuICAvLyBFcnJvciBzdGF0ZSB0YWtlcyBwcmlvcml0eVxuICBpZiAoc2NyYXBlU3RhdHVzID09PSAnZmFpbGVkJykge1xuICAgIHJldHVybiAnZXJyb3InO1xuICB9XG5cbiAgLy8gSElHSEVTVCBQUklPUklUWTogSWYgc2NyYXBlX3N0YXR1cyBpcyBjb21wbGV0ZWQsIGFsd2F5cyBzaG93IGNvbXBsZXRlZFxuICBpZiAoc2NyYXBlU3RhdHVzID09PSAnY29tcGxldGVkJykge1xuICAgIHJldHVybiAnY29tcGxldGVkJztcbiAgfVxuXG4gIC8vIENoZWNrIGpvYiBzdGF0dXNlcyBmb3IgbW9yZSBncmFudWxhciBzdGF0ZVxuICBpZiAoam9iU3RhdHVzZXMpIHtcbiAgICBjb25zdCBpbmdlc3Rpb25TdGF0dXMgPSBqb2JTdGF0dXNlc1snaW5nZXN0aW9uJ10/LnN0YXR1cztcbiAgICBjb25zdCByZXZpZXdzU3RhdHVzID0gam9iU3RhdHVzZXNbJ3Jldmlld3Mtc2NyYXBlciddPy5zdGF0dXM7XG4gICAgY29uc3Qgcm9vbXNTdGF0dXMgPSBqb2JTdGF0dXNlc1sncm9vbXMtc2NyYXBlciddPy5zdGF0dXM7XG5cbiAgICAvLyBJZiBpbmdlc3Rpb24gaXMgY29tcGxldGVkLCB3ZSdyZSBkb25lXG4gICAgaWYgKGluZ2VzdGlvblN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcpIHtcbiAgICAgIHJldHVybiAnY29tcGxldGVkJztcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgaW5nZXN0aW9uIGlzIHJ1bm5pbmcsIHNob3cgaW5nZXN0aW5nXG4gICAgaWYgKGluZ2VzdGlvblN0YXR1cyA9PT0gJ3J1bm5pbmcnKSB7XG4gICAgICByZXR1cm4gJ2luZ2VzdGluZyc7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHJldmlld3Mgc2NyYXBlciBpcyBydW5uaW5nLCBzaG93IHByb2Nlc3NpbmdcbiAgICBpZiAocmV2aWV3c1N0YXR1cyA9PT0gJ3J1bm5pbmcnKSB7XG4gICAgICByZXR1cm4gJ3Byb2Nlc3NpbmcnO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiByb29tcyBzY3JhcGVyIGlzIHJ1bm5pbmcsIHNob3cgc2NyYXBpbmdcbiAgICBpZiAocm9vbXNTdGF0dXMgPT09ICdydW5uaW5nJykge1xuICAgICAgcmV0dXJuICdzY3JhcGluZyc7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIGFsbCBqb2JzIGFyZSBjb21wbGV0ZWQgKG9yIG5vIGpvYnMgZXhpc3QpLCBjaGVjayBzY3JhcGVfc3RhdHVzXG4gICAgY29uc3QgYWxsSm9ic0NvbXBsZXRlZCA9IChcbiAgICAgICghcm9vbXNTdGF0dXMgfHwgcm9vbXNTdGF0dXMgPT09ICdjb21wbGV0ZWQnIHx8IHJvb21zU3RhdHVzID09PSAnZmFpbGVkJykgJiZcbiAgICAgICghcmV2aWV3c1N0YXR1cyB8fCByZXZpZXdzU3RhdHVzID09PSAnY29tcGxldGVkJyB8fCByZXZpZXdzU3RhdHVzID09PSAnZmFpbGVkJykgJiZcbiAgICAgICghaW5nZXN0aW9uU3RhdHVzIHx8IGluZ2VzdGlvblN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcgfHwgaW5nZXN0aW9uU3RhdHVzID09PSAnZmFpbGVkJylcbiAgICApO1xuICAgIFxuICAgIGlmIChhbGxKb2JzQ29tcGxldGVkICYmIGxhc3RTY3JhcGVkQXQpIHtcbiAgICAgIHJldHVybiAnY29tcGxldGVkJztcbiAgICB9XG4gIH1cblxuICAvLyBJZiBhY3RpdmVseSBzY3JhcGluZyAoZnJvbnRlbmQgc3RhdGUpLCBzaG93IHNjcmFwaW5nXG4gIGlmIChpc1NjcmFwaW5nKSB7XG4gICAgcmV0dXJuICdzY3JhcGluZyc7XG4gIH1cblxuICAvLyBJZiBzdGF0dXMgaXMgcnVubmluZyBhbmQgd2UgaGF2ZSBsYXN0X3NjcmFwZWRfYXQsIGNoZWNrIGlmIGpvYnMgYXJlIGRvbmVcbiAgaWYgKHNjcmFwZVN0YXR1cyA9PT0gJ3J1bm5pbmcnICYmIGxhc3RTY3JhcGVkQXQgJiYgIWlzU2NyYXBpbmcpIHtcbiAgICBpZiAoam9iU3RhdHVzZXMpIHtcbiAgICAgIGNvbnN0IGFsbEpvYnNEb25lID0gKFxuICAgICAgICAoIWpvYlN0YXR1c2VzWydyb29tcy1zY3JhcGVyJ10gfHwgam9iU3RhdHVzZXNbJ3Jvb21zLXNjcmFwZXInXS5zdGF0dXMgPT09ICdjb21wbGV0ZWQnIHx8IGpvYlN0YXR1c2VzWydyb29tcy1zY3JhcGVyJ10uc3RhdHVzID09PSAnZmFpbGVkJykgJiZcbiAgICAgICAgKCFqb2JTdGF0dXNlc1sncmV2aWV3cy1zY3JhcGVyJ10gfHwgam9iU3RhdHVzZXNbJ3Jldmlld3Mtc2NyYXBlciddLnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcgfHwgam9iU3RhdHVzZXNbJ3Jldmlld3Mtc2NyYXBlciddLnN0YXR1cyA9PT0gJ2ZhaWxlZCcpICYmXG4gICAgICAgICgham9iU3RhdHVzZXNbJ2luZ2VzdGlvbiddIHx8IGpvYlN0YXR1c2VzWydpbmdlc3Rpb24nXS5zdGF0dXMgPT09ICdjb21wbGV0ZWQnIHx8IGpvYlN0YXR1c2VzWydpbmdlc3Rpb24nXS5zdGF0dXMgPT09ICdmYWlsZWQnKVxuICAgICAgKTtcbiAgICAgIGlmIChhbGxKb2JzRG9uZSkge1xuICAgICAgICByZXR1cm4gJ2NvbXBsZXRlZCc7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIElmIHNjcmFwZSB3YXMgbW9yZSB0aGFuIDIwIG1pbnV0ZXMgYWdvIGFuZCB3ZSdyZSBub3QgYWN0aXZlbHkgc2NyYXBpbmcsIGFzc3VtZSBjb21wbGV0ZWRcbiAgICBjb25zdCBsYXN0U2NyYXBlZCA9IG5ldyBEYXRlKGxhc3RTY3JhcGVkQXQpO1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3QgbWludXRlc1NpbmNlU2NyYXBlID0gKG5vdy5nZXRUaW1lKCkgLSBsYXN0U2NyYXBlZC5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MCk7XG4gICAgaWYgKG1pbnV0ZXNTaW5jZVNjcmFwZSA+IDIwKSB7XG4gICAgICByZXR1cm4gJ2NvbXBsZXRlZCc7XG4gICAgfVxuICAgIHJldHVybiAnc2NyYXBpbmcnO1xuICB9XG5cbiAgLy8gSWYgc3RhdHVzIGlzIHJ1bm5pbmcgYW5kIHdlJ3JlIGFjdGl2ZWx5IHNjcmFwaW5nLCBzaG93IHNjcmFwaW5nXG4gIGlmIChzY3JhcGVTdGF0dXMgPT09ICdydW5uaW5nJykge1xuICAgIHJldHVybiAnc2NyYXBpbmcnO1xuICB9XG5cbiAgaWYgKHNjcmFwZVN0YXR1cyA9PT0gJ3BlbmRpbmcnIHx8ICFsYXN0U2NyYXBlZEF0KSB7XG4gICAgcmV0dXJuICdyZWFkeSc7XG4gIH1cblxuICAvLyBEZWZhdWx0OiBpZiB3ZSBoYXZlIGxhc3Rfc2NyYXBlZF9hdCBidXQgbm8gY2xlYXIgc3RhdHVzLCBhc3N1bWUgY29tcGxldGVkXG4gIHJldHVybiAnY29tcGxldGVkJztcbn1cblxuLyoqXG4gKiBHZXQgYW5pbWF0aW9uIGNsYXNzIGZvciBhIHByb2dyZXNzIHN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbmltYXRpb25DbGFzcyhzdGF0ZTogUHJvZ3Jlc3NTdGF0ZSk6IHN0cmluZyB7XG4gIGNvbnN0IGNvbmZpZyA9IFBST0dSRVNTX1NUQVRFX0NPTkZJR1tzdGF0ZV07XG4gIGlmICghY29uZmlnLmFuaW1hdGlvbiB8fCBjb25maWcuYW5pbWF0aW9uID09PSAnbm9uZScpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBzd2l0Y2ggKGNvbmZpZy5hbmltYXRpb24pIHtcbiAgICBjYXNlICdwdWxzZSc6XG4gICAgICByZXR1cm4gJ2FuaW1hdGUtcHVsc2UnO1xuICAgIGNhc2UgJ3NwaW4nOlxuICAgICAgcmV0dXJuICdhbmltYXRlLXNwaW4nO1xuICAgIGNhc2UgJ2ZhZGUnOlxuICAgICAgcmV0dXJuICdvcGFjaXR5LTc1JztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbiJdLCJuYW1lcyI6WyJQUk9HUkVTU19TVEFURV9DT05GSUciLCJyZWFkeSIsImxhYmVsIiwiaWNvbiIsImNvbG9yIiwiYmdDb2xvciIsImJvcmRlckNvbG9yIiwiYW5pbWF0aW9uIiwiZGVzY3JpcHRpb24iLCJzY3JhcGVfaW5pdGlhdGVkIiwic2NyYXBpbmciLCJwcm9jZXNzaW5nIiwiaW5nZXN0aW5nIiwidXBkYXRpbmdfdWkiLCJjb21wbGV0ZWQiLCJlcnJvciIsImRldGVybWluZVByb2dyZXNzU3RhdGUiLCJzY3JhcGVTdGF0dXMiLCJsYXN0U2NyYXBlZEF0IiwiaXNTY3JhcGluZyIsImpvYlN0YXR1c2VzIiwiaW5nZXN0aW9uU3RhdHVzIiwic3RhdHVzIiwicmV2aWV3c1N0YXR1cyIsInJvb21zU3RhdHVzIiwiYWxsSm9ic0NvbXBsZXRlZCIsImFsbEpvYnNEb25lIiwibGFzdFNjcmFwZWQiLCJEYXRlIiwibm93IiwibWludXRlc1NpbmNlU2NyYXBlIiwiZ2V0VGltZSIsImdldEFuaW1hdGlvbkNsYXNzIiwic3RhdGUiLCJjb25maWciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/progressStates.ts\n"));

/***/ })

});