import { PrismaClient } from '@prisma/client';
import { config } from 'dotenv';
import * as path from 'path';
import * as readline from 'readline';
import * as fs from 'fs';

// Load environment variables from root .env file
config({ path: path.join(__dirname, '..', '..', '.env') });

// Only need local Prisma for reading data
const localDatabaseUrl = process.env.DATABASE_URL || 'postgresql://postgres:postgres@localhost:5432/airbnb_tracker';
const localPrisma = new PrismaClient({
  datasources: {
    db: {
      url: localDatabaseUrl,
    },
  },
});

// Create readline interface for user confirmation
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

function question(query: string): Promise<string> {
  return new Promise((resolve) => {
    rl.question(query, resolve);
  });
}

// Helper function to escape SQL strings
function escapeSqlString(str: string | null | undefined): string {
  if (!str) return 'NULL';
  return `'${str.replace(/'/g, "''")}'`;
}

// Helper function to format JSON for SQL
function formatJsonForSql(json: any): string {
  if (!json) return 'NULL';
  const jsonStr = JSON.stringify(json).replace(/'/g, "''");
  return `'${jsonStr}'::jsonb`;
}

// Helper function to format timestamp for SQL
function formatTimestamp(date: Date | null | undefined): string {
  if (!date) return 'NULL';
  return `'${date.toISOString().replace('T', ' ').replace('Z', '')}'::timestamp`;
}

async function generateSyncSQL() {
  try {
    console.log('üîÑ Preparing SQL statements to sync snapshots to production (via MCP Supabase)...\n');
    console.log(`   Local DB: ${localDatabaseUrl.replace(/:[^:@]+@/, ':****@')}\n`);

    console.log('üîç Finding simulated snapshots in local database...\n');

    // Get all listings with snapshots from local
    const localListings = await localPrisma.listing.findMany({
      include: {
        snapshots: {
          orderBy: { version: 'desc' },
          include: {
            photos: {
              orderBy: { order: 'asc' },
            },
            reviews: {
              orderBy: { date: 'desc' },
            },
            scrapeRun: true,
          },
        },
        trackedUrl: true,
      },
    });

    if (localListings.length === 0) {
      console.log('‚ùå No listings with snapshots found in local database.');
      process.exit(0);
    }

    console.log(`üìã Found ${localListings.length} listing(s) with snapshots.\n`);

    const sqlStatements: string[] = [];
    sqlStatements.push('-- SQL statements to sync snapshots from local to production');
    sqlStatements.push('-- Generated by sync-snapshots-mcp.ts');
    sqlStatements.push('-- Execute these via MCP Supabase execute_sql\n');

    // For each listing, generate SQL
    for (const localListing of localListings) {
      console.log(`üì∏ Processing listing: ${localListing.title || localListing.id}`);
      console.log(`   Local snapshots: ${localListing.snapshots.length}`);

      sqlStatements.push(`-- Listing: ${localListing.title || localListing.id}`);
      sqlStatements.push(`-- Tracked URL: ${localListing.trackedUrl.url}\n`);

      // Use subqueries to look up production IDs
      const trackedUrlSubquery = `(SELECT id FROM "TrackedUrl" WHERE url = ${escapeSqlString(localListing.trackedUrl.url)} LIMIT 1)`;
      const listingSubquery = `(
        SELECT id FROM "Listing" 
        WHERE "trackedUrlId" = ${trackedUrlSubquery}
        LIMIT 1
      )`;

      // For each snapshot, generate INSERT statements
      for (const localSnapshot of localListing.snapshots) {
        console.log(`   üì∏ Preparing snapshot version ${localSnapshot.version}...`);

        sqlStatements.push(`-- Snapshot version ${localSnapshot.version}`);
        sqlStatements.push(`-- Check if snapshot already exists (skip if version exists for this listing):`);
        sqlStatements.push(`DO $$`);
        sqlStatements.push(`DECLARE`);
        sqlStatements.push(`  prod_tracked_url_id TEXT;`);
        sqlStatements.push(`  prod_listing_id TEXT;`);
        sqlStatements.push(`  existing_snapshot_id TEXT;`);
        sqlStatements.push(`  new_snapshot_id TEXT := gen_random_uuid()::TEXT;`);
        sqlStatements.push(`BEGIN`);
        sqlStatements.push(`  -- Look up tracked URL`);
        sqlStatements.push(`  SELECT id INTO prod_tracked_url_id FROM "TrackedUrl" WHERE url = ${escapeSqlString(localListing.trackedUrl.url)} LIMIT 1;`);
        sqlStatements.push(`  IF prod_tracked_url_id IS NULL THEN`);
        sqlStatements.push(`    RAISE NOTICE 'Tracked URL not found: ${localListing.trackedUrl.url}';`);
        sqlStatements.push(`    RETURN;`);
        sqlStatements.push(`  END IF;`);
        sqlStatements.push(`  -- Look up or create listing`);
        sqlStatements.push(`  SELECT id INTO prod_listing_id FROM "Listing" WHERE "trackedUrlId" = prod_tracked_url_id LIMIT 1;`);
        sqlStatements.push(`  IF prod_listing_id IS NULL THEN`);
        sqlStatements.push(`    prod_listing_id := gen_random_uuid()::TEXT;`);
        sqlStatements.push(`    INSERT INTO "Listing" (id, "trackedUrlId", "airbnbId", title, description, location) VALUES (`);
        sqlStatements.push(`      prod_listing_id,`);
        sqlStatements.push(`      prod_tracked_url_id,`);
        sqlStatements.push(`      ${escapeSqlString(localListing.airbnbId || '')},`);
        sqlStatements.push(`      ${escapeSqlString(localListing.title || '')},`);
        sqlStatements.push(`      ${escapeSqlString(localListing.description || '')},`);
        sqlStatements.push(`      ${escapeSqlString(localListing.location || '')}`);
        sqlStatements.push(`    );`);
        sqlStatements.push(`  END IF;`);
        sqlStatements.push(`  -- Check if snapshot version already exists`);
        sqlStatements.push(`  SELECT id INTO existing_snapshot_id FROM "ListingSnapshot" WHERE "listingId" = prod_listing_id AND version = ${localSnapshot.version} LIMIT 1;`);
        sqlStatements.push(`  IF existing_snapshot_id IS NOT NULL THEN`);
        sqlStatements.push(`    RAISE NOTICE 'Snapshot version ${localSnapshot.version} already exists for this listing, skipping.';`);
        sqlStatements.push(`    RETURN;`);
        sqlStatements.push(`  END IF;`);
        sqlStatements.push(`  -- Insert snapshot`);
        sqlStatements.push(`  INSERT INTO "ListingSnapshot" (`);
        sqlStatements.push(`    id, "listingId", version, description, amenities, price, currency, rating, "reviewCount", "createdAt"`);
        sqlStatements.push(`  ) VALUES (`);
        sqlStatements.push(`    new_snapshot_id,`);
        sqlStatements.push(`    prod_listing_id,`);
        sqlStatements.push(`    ${localSnapshot.version},`);
        sqlStatements.push(`    ${escapeSqlString(localSnapshot.description)},`);
        sqlStatements.push(`    ${formatJsonForSql(localSnapshot.amenities)},`);
        sqlStatements.push(`    ${localSnapshot.price ?? 'NULL'},`);
        sqlStatements.push(`    ${escapeSqlString(localSnapshot.currency)},`);
        sqlStatements.push(`    ${localSnapshot.rating ?? 'NULL'},`);
        sqlStatements.push(`    ${localSnapshot.reviewCount ?? 'NULL'},`);
        sqlStatements.push(`    ${formatTimestamp(localSnapshot.createdAt)}`);
        sqlStatements.push(`  );`);

        // Insert photos
        if (localSnapshot.photos.length > 0) {
          sqlStatements.push(`  -- Insert ${localSnapshot.photos.length} photos`);
          for (let i = 0; i < localSnapshot.photos.length; i++) {
            const photo = localSnapshot.photos[i];
            sqlStatements.push(`  INSERT INTO "Photo" (id, "listingId", "snapshotId", url, caption, "order", "createdAt")`);
            sqlStatements.push(`  VALUES (`);
            sqlStatements.push(`    gen_random_uuid()::TEXT,`);
            sqlStatements.push(`    prod_listing_id,`);
            sqlStatements.push(`    new_snapshot_id,`);
            sqlStatements.push(`    ${escapeSqlString(photo.url)},`);
            sqlStatements.push(`    ${escapeSqlString(photo.caption)},`);
            sqlStatements.push(`    ${photo.order ?? i},`);
            sqlStatements.push(`    ${formatTimestamp(photo.createdAt)}`);
            sqlStatements.push(`  ) ON CONFLICT DO NOTHING;`);
          }
        }

        // Insert reviews
        if (localSnapshot.reviews.length > 0) {
          sqlStatements.push(`  -- Insert ${localSnapshot.reviews.length} reviews`);
          for (const review of localSnapshot.reviews) {
            sqlStatements.push(`  INSERT INTO "Review" (id, "listingId", "snapshotId", "reviewId", "reviewerName", "reviewerAvatar", rating, comment, date, "createdAt")`);
            sqlStatements.push(`  VALUES (`);
            sqlStatements.push(`    gen_random_uuid()::TEXT,`);
            sqlStatements.push(`    prod_listing_id,`);
            sqlStatements.push(`    new_snapshot_id,`);
            sqlStatements.push(`    ${escapeSqlString(review.reviewId)},`);
            sqlStatements.push(`    ${escapeSqlString(review.reviewerName)},`);
            sqlStatements.push(`    ${escapeSqlString(review.reviewerAvatar)},`);
            sqlStatements.push(`    ${review.rating ?? 'NULL'},`);
            sqlStatements.push(`    ${escapeSqlString(review.comment)},`);
            sqlStatements.push(`    ${formatTimestamp(review.date)},`);
            sqlStatements.push(`    ${formatTimestamp(review.createdAt)}`);
            sqlStatements.push(`  ) ON CONFLICT ("reviewId") DO UPDATE SET`);
            sqlStatements.push(`    "snapshotId" = EXCLUDED."snapshotId",`);
            sqlStatements.push(`    rating = EXCLUDED.rating,`);
            sqlStatements.push(`    comment = EXCLUDED.comment;`);
          }
        }

        // Insert scrape run if it exists
        if (localSnapshot.scrapeRun) {
          sqlStatements.push(`  -- Insert scrape run`);
          sqlStatements.push(`  INSERT INTO "ScrapeRun" (id, "trackedUrlId", status, error, "startedAt", "completedAt", "apifyRunId", "snapshotId")`);
          sqlStatements.push(`  VALUES (`);
          sqlStatements.push(`    gen_random_uuid()::TEXT,`);
          sqlStatements.push(`    prod_tracked_url_id,`);
          sqlStatements.push(`    ${escapeSqlString(localSnapshot.scrapeRun.status)},`);
          sqlStatements.push(`    ${escapeSqlString(localSnapshot.scrapeRun.error)},`);
          sqlStatements.push(`    ${formatTimestamp(localSnapshot.scrapeRun.startedAt)},`);
          sqlStatements.push(`    ${formatTimestamp(localSnapshot.scrapeRun.completedAt)},`);
          sqlStatements.push(`    ${escapeSqlString(localSnapshot.scrapeRun.apifyRunId)},`);
          sqlStatements.push(`    new_snapshot_id`);
          sqlStatements.push(`  ) ON CONFLICT DO NOTHING;`);
        }

        sqlStatements.push(`END $$;\n`);
      }
    }

    // Write SQL to file
    const sqlFile = path.join(__dirname, '..', '..', 'sync-snapshots.sql');
    fs.writeFileSync(sqlFile, sqlStatements.join('\n'));
    
    console.log(`\n‚úÖ SQL statements generated successfully!`);
    console.log(`   File: ${sqlFile}`);
    console.log(`\nüí° Next steps:`);
    console.log(`   1. Review the SQL file to ensure it's correct`);
    console.log(`   2. The SQL can be executed via MCP Supabase execute_sql`);
    console.log(`   3. Or you can execute it manually in Supabase SQL Editor`);

  } catch (error) {
    console.error('‚ùå Error generating SQL:', error);
    throw error;
  } finally {
    await localPrisma.$disconnect();
    rl.close();
  }
}

generateSyncSQL();
